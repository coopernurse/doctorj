#!/usr/bin/env python

import sys
import re
import os.path
import codecs
import markdown
import tempfile
import getopt
import time
from subprocess import call

orderly_re = re.compile(r"[mM]essage:\s*(\S+).*?\.orderly}(.+?)~~~~", re.DOTALL)

default_template_html = """
<html>
    <head>
        <title>API Documentation</title>
        <style>
            body { font-family: verdana; }
            pre { padding: 20px; margin: 25px; background: eee; }
            div.toc { padding: 5px; margin: 10px;  }
            div.toc ul { list-style-type: none; margin: 3px; padding: 5px 5px 0px 15px; }
        </style>
    </head>
    <body>
        {{ CONTENT }}

        <hr />
        <h5>generated by <a href="https://github.com/coopernurse/doctorj">doctorj</a> - {{ DATE }}</h5>
    </body>
</html>
"""

def write_temp_file(data, encoding="utf8"):
    (tmphandle, tmppath) = tempfile.mkstemp()
    c = codecs.getencoder(encoding)
    f = os.fdopen(tmphandle, 'w')
    f.write(c(data)[0])
    f.close()
    return tmppath

def add(a, b):
    """
    >>> add(1, 2)
    >>> 3
    """
    return a+b

def get_rel_path(base_fname, fname):
    """
    Returns a fully qualified path for fname relative to the base_fname
    
    Example:

        >>> get_rel_path("/foo/bar", "../blam")
        >>> "/foo/blam"
    """
    dirname = os.path.dirname(os.path.abspath(base_fname))
    return os.path.join(dirname, fname)

def write_file(fname, data, encoding="utf8"):
    c = codecs.getencoder(encoding)
    f = open(fname, "w")
    f.write(c(data)[0])
    f.close()

def read_file(fname, encoding="utf8"):
    """
    Accepts a path and returns the contents of the path as a string

    Optionally accepts encoding of file to read
    """
    f = codecs.open(fname, encoding=encoding)
    d = f.read()
    f.close()
    return d

def parse_orderly_blocks(md):
    """
    Accepts markdown string 'md' and returns a list of tuples that
    match the 'orderly' regex

    Example:

        Message: foo_request
        ~~~~{.orderly}
        object {
            string name;
        }*;
        ~~~~

    Would return:

       # newlines stripped for example purposes
       [ ("foo_request", "object { string name; }*;") ]
    
    """
    return orderly_re.findall(md)

def markdown_to_html(md):
    """
    Accepts markdown string 'md' and converts to html

    Caller can then write this html string to a file/socket/etc
    """
    m = markdown.Markdown(extensions=["toc", "fenced_code"])
    return m.convert(md)

def orderly_to_jsonschema(orderly, orderly_bin="node-orderly2jsonschema"):
    """
    Accepts orderly string and converts to jsonschema

    This implementation calls orderly.js using node

    See: https://github.com/zaach/orderly.js
    """
    infile_tmp = write_temp_file(orderly)
    (tmphandle, outfile_tmp) = tempfile.mkstemp()
    os.close(tmphandle)
    cmd = [ orderly_bin, infile_tmp, outfile_tmp ]
    call(cmd)
    jsonschema = read_file(outfile_tmp)
    os.unlink(infile_tmp)
    os.unlink(outfile_tmp)
    return jsonschema

def parse_orderly_convert_jsonschema(md, orderly_bin=None):
    """
    Accepts markdown string 'md', parses all orderly blocks, and
    returns a list of tuples with these values:
      t[0] - name of message
      t[1] - orderly source
      t[2] - json schema
    """
    l = []
    for block in parse_orderly_blocks(md):
        l.append((block[0], block[1], orderly_to_jsonschema(block[1], orderly_bin)))
    return l

def merge_html_template(content, template_html=None):
    """
    Merges content HTML into template_html by replacing {{ CONTENT }} token
    contained in template_html
    """
    if template_html == None:
        template_html = default_template_html
    html = template_html.replace("{{ CONTENT }}", content)
    html = html.replace("{{ DATE }}", time.strftime("%b %d %Y %H:%M:%S"))
    return html

def usage():
    print "Usage: doctorj.py input.md [--outdir=dirname] [--html=htmlfilename]"
    print "                           [--orderly=orderlybin] [--clean]"
    sys.exit(1)

def main():
    if len(sys.argv) < 2:
        usage()
    input_file = sys.argv[1]
    try:
        params = ["outdir=", "html=", "orderly=", "template=", "clean"]
        opts, args = getopt.getopt(sys.argv[2:], "", params)
    except Exception, err:
        print str(err)
        usage()
    outdir  = "out"
    html    = None
    orderly = None
    template_html = None
    clean   = False
    for o, a in opts:
        if o == "--outdir":
            outdir = a
        elif o == "--html":
            html = a
        elif o == "--orderly":
            orderly = a
        elif o == "--template":
            template_html = read_file(a)
        elif o == "--clean":
            clean = True
        else:
            print "Unknown argument: %s" % o
            usage()
    if not os.path.exists(outdir):
        print "Creating output dir: %s" % outdir
        os.mkdir(outdir)
    if not os.path.isdir(outdir):
        print "Directory not found: %s" % outdir
        usage()
    if not os.path.exists(input_file):
        print "Markdown file not found: %s" % input_file
        sys.exit(1)
    if not html:
        input_base = os.path.basename(input_file)
        pos = input_base.find(".")
        html = os.path.join(outdir, input_base[:pos] + ".html")
    if orderly == None:
        orderly = "node-orderly2jsonschema"
    if clean:
        print "Cleaning output dir: %s" % outdir
        for f in os.listdir(outdir):
            os.unlink(os.path.join(outdir, f))
    print "Writing output to: %s" % outdir
    print "   Writing: %s" % html
    md = read_file(input_file)
    write_file(html, merge_html_template(markdown_to_html(md), template_html))
    for b in parse_orderly_convert_jsonschema(md, orderly_bin=orderly):
        fname = os.path.join(outdir, b[0]+".json")
        print "   Writing: %s" % fname
        write_file(fname, b[2])

#############################################################

if __name__ == '__main__':
    main()
